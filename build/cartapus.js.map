{"version":3,"file":"cartapus.js","sources":["../node_modules/tiny-emitter/index.js","../src/cartapus.js"],"sourcesContent":["function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n","/**\n * @file Cartapus core file, dispatches events based on [data-cartapus] elements' visibility in the viewport.\n * @author Jordan Thiervoz <jordanthiervoz@gmail.com>\n */\n\nimport Emitter from 'tiny-emitter'\n\n/**\n * Creates a new Cartapus instance, starting to watch every `[data-cartapus]` elements' visibility right away.\n *\n * Usually you will only need to instanciate Cartapus once for your whole App.\n *\n * @param {Object} [options] — User options.\n * @param {Element} [options.root=document] — The root DOM element into which [data-cartapus] targets will be watched.\n * @param {String} [options.rootMargin=\"0px\"] — A CSS margin property string defining offsets into the `root` element.\n * @param {Number} [options.threshold=0] — A number between 0 and 1 which defines the percentage of height that must be into the viewport for an element to be considered \"visible\".\n * @param {Boolean} [options.once=false] — If \"true\", elements will only toggle to \"visible\" once and never return to their \"hidden\" state.\n * @param {Boolean} [options.event=true] — If \"true\", events will be triggered when an element changes its state. A CustomEvent is triggered on the related element, and an event is also triggered on the Cartapus instance.\n *\n * @extends Emitter\n * @class\n */\nexport default class Cartapus extends Emitter {\n\n  /**\n   * Creates a new Cartapus instance, starting to watch every `[data-cartapus]` elements' visibility right away.\n   *\n   * Usually you will only need to instanciate Cartapus once for your whole App.\n   *\n   * @param {Object} [options] — User options.\n   * @param {Element} [options.root=document] — The root DOM element into which [data-cartapus] targets will be watched.\n   * @param {String} [options.rootMargin=\"0px\"] — A CSS margin property string defining offsets into the `root` element.\n   * @param {Number} [options.threshold=0] — A number between 0 and 1 which defines the percentage of height that must be into the viewport for an element to be considered \"visible\".\n   * @param {Boolean} [options.once=false] — If \"true\", elements will only toggle to \"visible\" once and never return to their \"hidden\" state.\n   * @param {Boolean} [options.event=true] — If \"true\", events will be triggered when an element changes its state. A CustomEvent is triggered on the related element, and an event is also triggered on the Cartapus instance.\n   *\n   * @extends Emitter\n   * @constructor\n   */\n  constructor(options = {}) {\n    super()\n\n    // Bind callback method.\n    this.intersect = this.intersect.bind(this)\n\n    // Set user options based on default options.\n    const defaults = {\n      root: null,\n      rootMargin: '0px',\n      threshold: 0,\n      once: false,\n      events: true\n    }\n\n    this.options = Object.assign(defaults, options)\n\n    // Creates the default observer then start.\n    this.createMainObserver()\n    this.init()\n  }\n\n  /**\n   * Creates the main IntersectionObserver used with the default options.\n   *\n   * @private\n   * @returns {void}\n   */\n  createMainObserver() {\n    this.observers = [{\n      observer: new IntersectionObserver(this.intersect, this.options),\n      threshold: this.options.threshold,\n      rootMargin: this.options.rootMargin,\n      elements: []\n    }]\n  }\n\n  /**\n   * Initialization method, starts the IntersectionObservers.\n   *\n   * @private\n   * @returns {void}\n   */\n  init() {\n    this.getElems()\n    this.createObservers()\n    this.observe()\n  }\n\n  /**\n   * Gets the [data-cartapus] elements from root element.\n   *\n   * @private\n   * @returns {void}\n   */\n  getElems() {\n    const root = this.options.root === null ? document : this.options.root\n\n    this.elems = root.querySelectorAll('[data-cartapus]')\n  }\n\n  /**\n   * For each [data-cartapus] element, check its inner data-cartapus parameters\n   * Create new IntersectionObservers accordingly if parameters differs from the main observer.\n   *\n   * @private\n   * @returns {void}\n   */\n  createObservers() {\n    for (const el of this.elems) {\n      // If element has data-cartapus-threshold attribute.\n      if (el.dataset.cartapusThreshold || el.dataset.cartapusRootMargin) {\n        const threshold = el.dataset.cartapusThreshold ? parseFloat(el.dataset.cartapusThreshold) : this.options.threshold\n        const rootMargin = el.dataset.cartapusRootMargin ? el.dataset.cartapusRootMargin : this.options.rootMargin\n        let found = false\n\n        // If an observer already exists with the same threshold & the same rootMargin, add element to this observer.\n        for (const observer of this.observers) {\n          if (threshold === observer.threshold && rootMargin === observer.rootMargin) {\n            found = true\n\n            observer.elements.push(el)\n          }\n        }\n\n        // If no observer has the same threshold & rootMargin, create a new one with the new options.\n        if (!found) {\n          const observer = {\n            observer: new IntersectionObserver(this.intersect, Object.assign(this.options, { threshold, rootMargin })),\n            threshold,\n            rootMargin,\n            elements: [el]\n          }\n\n          this.observers.push(observer)\n        }\n      } else this.observers[0].elements.push(el)\n    }\n  }\n\n  /**\n   * Callback function triggered by the observers.\n   * Sets the data-cartapus attribute accordingly to the visibility of the elements.\n   * Triggers the custom events if the `events` option is enabled.\n   *\n   * @param {array.<IntersectionObserverEntry>} entries — An array of entries that intersected with the root.\n   * @param {IntersectionObserver} observer — The observer that triggered the event.\n   *\n   * @private\n   * @returns {void}\n   */\n  intersect(entries, observer) {\n    entries.forEach((entry) => {\n      // Set data-cartapus attribute value either to \"visible\" or \"hidden\".\n      if (entry.isIntersecting) {\n        entry.target.dataset.cartapus = 'visible'\n\n        // Stop observing this element if \"once\" options it true.\n        if (this.options.once && entry.target.dataset.cartapusOnce !== 'false') observer.unobserve(entry.target)\n      } else entry.target.dataset.cartapus = 'hidden'\n\n      if (this.options.events) this.dispatch(entry)\n    })\n  }\n\n  /**\n   * Triggers the CustomEvent `cartapusintersect` on the entry's target.\n   * Also triggers an `intersect` event on the class instance.\n   *\n   * @param {IntersectionObserverEntry} entry — The entry that intersected.\n   *\n   * @private\n   * @returns {void}\n   */\n  dispatch(entry) {\n    // Create event with details.\n    const detail = {\n      element: entry.target,\n      visible: entry.isIntersecting,\n      intersection: entry\n    }\n    const event = new CustomEvent('cartapusintersect', { detail })\n\n    // Dispatch element and instance events.\n    entry.target.dispatchEvent(event)\n    this.emit('intersect', detail)\n  }\n\n  /**\n   * Turns on all the observers to watch all of their related targets.\n   *\n   * This will trigger Cartapus events if events are turned on.\n   *\n   * @public\n   * @returns {void}\n   */\n  observe() {\n    this.observers.forEach((observer) => {\n      observer.elements.forEach((el) => {\n        observer.observer.observe(el)\n      })\n    })\n  }\n\n  /**\n   * Turns off all the observers to stop watching all of their related targets.\n   *\n   * @public\n   * @returns {void}\n   */\n  unobserve() {\n    this.observers.forEach((observer) => {\n      observer.elements.forEach((el) => {\n        observer.observer.unobserve(el)\n      })\n    })\n  }\n\n  /**\n   * Turns off observers and empty their related targets.\n   *\n   * @public\n   * @returns {void}\n   */\n  destroy() {\n    this.unobserve()\n\n    this.observers.forEach((observer) => {\n      observer.elements = []\n    })\n  }\n\n  /**\n   * Resets everything.\n   * Turns off observers and resets their targets.\n   * Then calls `this.init()` to restart everything with new elements to observe.\n   * This will trigger Cartapus events if events are turned on.\n   *\n   * @public\n   * @returns {void}\n   */\n  reset() {\n    this.destroy()\n    this.init()\n  }\n}\n"],"names":["E","prototype","on","name","callback","ctx","e","this","push","fn","once","self","listener","off","apply","arguments","_","emit","data","slice","call","evtArr","i","len","length","evts","liveEvents","tinyEmitter","options","_this","_Emitter","intersect","bind","_assertThisInitialized","Object","assign","root","rootMargin","threshold","events","createMainObserver","init","Emitter","observers","observer","IntersectionObserver","elements","getElems","createObservers","observe","document","elems","querySelectorAll","_iterator","_createForOfIteratorHelperLoose","el","_step","value","dataset","cartapusThreshold","cartapusRootMargin","parseFloat","found","_iterator2","_step2","entries","forEach","entry","isIntersecting","target","cartapus","_this2","cartapusOnce","unobserve","dispatch","detail","element","visible","intersection","event","CustomEvent","dispatchEvent","destroy","reset"],"mappings":"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"}