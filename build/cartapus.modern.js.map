{"version":3,"file":"cartapus.modern.js","sources":["../src/cartapus.js"],"sourcesContent":["/**\r\n * @file Cartapus core file, dispatches events based on [data-cartapus] elements' visibility in the viewport.\r\n * @author Jordan Thiervoz <jordanthiervoz@gmail.com>\r\n */\r\n\r\nimport Emitter from 'tiny-emitter'\r\n\r\n/**\r\n * Creates a new Cartapus instance, starting to watch every `[data-cartapus]` elements' visibility right away.\r\n *\r\n * Usually you will only need to instanciate Cartapus once for your whole App.\r\n *\r\n * @param {Object} [options] — User options.\r\n * @param {Element} [options.root=document] — The root DOM element into which [data-cartapus] targets will be watched.\r\n * @param {String} [options.rootMargin=\"0px\"] — A CSS margin property string defining offsets into the `root` element.\r\n * @param {Number} [options.threshold=0] — A number between 0 and 1 which defines the percentage of height that must be into the viewport for an element to be considered \"visible\".\r\n * @param {Boolean} [options.once=false] — If \"true\", elements will only toggle to \"visible\" once and never return to their \"hidden\" state.\r\n * @param {Boolean} [options.event=true] — If \"true\", events will be triggered when an element changes its state. A CustomEvent is triggered on the related element, and an event is also triggered on the Cartapus instance.\r\n *\r\n * @extends Emitter\r\n * @class\r\n */\r\nexport default class Cartapus extends Emitter {\r\n\r\n  /**\r\n   * Creates a new Cartapus instance, starting to watch every `[data-cartapus]` elements' visibility right away.\r\n   *\r\n   * Usually you will only need to instanciate Cartapus once for your whole App.\r\n   *\r\n   * @param {Object} [options] — User options.\r\n   * @param {Element} [options.root=document] — The root DOM element into which [data-cartapus] targets will be watched.\r\n   * @param {String} [options.rootMargin=\"0px\"] — A CSS margin property string defining offsets into the `root` element.\r\n   * @param {Number} [options.threshold=0] — A number between 0 and 1 which defines the percentage of height that must be into the viewport for an element to be considered \"visible\".\r\n   * @param {Boolean} [options.once=false] — If \"true\", elements will only toggle to \"visible\" once and never return to their \"hidden\" state.\r\n   * @param {Boolean} [options.event=true] — If \"true\", events will be triggered when an element changes its state. A CustomEvent is triggered on the related element, and an event is also triggered on the Cartapus instance.\r\n   *\r\n   * @extends Emitter\r\n   * @constructor\r\n   */\r\n  constructor(options = {}) {\r\n    super()\r\n\r\n    // Bind callback method.\r\n    this.intersect = this.intersect.bind(this)\r\n\r\n    // Set user options based on default options.\r\n    const defaults = {\r\n      root: null,\r\n      rootMargin: '0px',\r\n      threshold: 0,\r\n      once: false,\r\n      events: true\r\n    }\r\n\r\n    this.options = Object.assign(defaults, options)\r\n\r\n    // Creates the default observer then start.\r\n    this.createMainObserver()\r\n    this.init()\r\n  }\r\n\r\n  /**\r\n   * Creates the main IntersectionObserver used with the default options.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  createMainObserver() {\r\n    this.observers = [{\r\n      observer: new IntersectionObserver(this.intersect, this.options),\r\n      threshold: this.options.threshold,\r\n      elements: []\r\n    }]\r\n  }\r\n\r\n  /**\r\n   * Initialization method, starts the IntersectionObservers.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  init() {\r\n    this.getElems()\r\n    this.createObservers()\r\n    this.observe()\r\n  }\r\n\r\n  /**\r\n   * Gets the [data-cartapus] elements from root element.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  getElems() {\r\n    const root = this.options.root === null ? document : this.options.root\r\n\r\n    this.elems = root.querySelectorAll('[data-cartapus]')\r\n  }\r\n\r\n  /**\r\n   * For each [data-cartapus] element, check its inner data-cartapus parameters\r\n   * Create new IntersectionObservers accordingly if parameters differs from the main observer.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  createObservers() {\r\n    for (const el of this.elems) {\r\n      // If element has data-cartapus-threshold attribute.\r\n      if (el.dataset.cartapusThreshold) {\r\n        const threshold = parseFloat(el.dataset.cartapusThreshold)\r\n        let found = false\r\n\r\n        // If an observer already exists with the same threshold, add element to this observer.\r\n        for (const observer of this.observers) {\r\n          if (threshold === observer.threshold) {\r\n            found = true\r\n\r\n            observer.elements.push(el)\r\n          }\r\n        }\r\n\r\n        // If no observer has the same threshold, create a new one with the new threshold.\r\n        if (!found) {\r\n          const observer = {\r\n            observer: new IntersectionObserver(this.intersect, Object.assign(this.options, { threshold })),\r\n            threshold,\r\n            elements: [el]\r\n          }\r\n\r\n          this.observers.push(observer)\r\n        }\r\n      } else this.observers[0].elements.push(el)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback function triggered by the observers.\r\n   * Sets the data-cartapus attribute accordingly to the visibility of the elements.\r\n   * Triggers the custom events if the `events` option is enabled.\r\n   *\r\n   * @param {array.<IntersectionObserverEntry>} entries — An array of entries that intersected with the root.\r\n   * @param {IntersectionObserver} observer — The observer that triggered the event.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  intersect(entries, observer) {\r\n    entries.forEach((entry) => {\r\n      // Set data-cartapus attribute value either to \"visible\" or \"hidden\".\r\n      if (entry.isIntersecting) {\r\n        entry.target.dataset.cartapus = 'visible'\r\n\r\n        // Stop observing this element if \"once\" options it true.\r\n        if (this.options.once && entry.target.dataset.cartapusOnce !== 'false') observer.unobserve(entry.target)\r\n      } else entry.target.dataset.cartapus = 'hidden'\r\n\r\n      if (this.options.events) this.dispatch(entry)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Triggers the CustomEvent `cartapusintersect` on the entry's target.\r\n   * Also triggers an `intersect` event on the class instance.\r\n   *\r\n   * @param {IntersectionObserverEntry} entry — The entry that intersected.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  dispatch(entry) {\r\n    // Create event with details.\r\n    const detail = {\r\n      element: entry.target,\r\n      visible: entry.isIntersecting,\r\n      intersection: entry\r\n    }\r\n    const event = new CustomEvent('cartapusintersect', { detail })\r\n\r\n    // Dispatch element and instance events.\r\n    entry.target.dispatchEvent(event)\r\n    this.emit('intersect', detail)\r\n  }\r\n\r\n  /**\r\n   * Turns on all the observers to watch all of their related targets.\r\n   *\r\n   * This will trigger Cartapus events if events are turned on.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  observe() {\r\n    this.observers.forEach((observer) => {\r\n      observer.elements.forEach((el) => {\r\n        observer.observer.observe(el)\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Turns off all the observers to stop watching all of their related targets.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  unobserve() {\r\n    this.observers.forEach((observer) => {\r\n      observer.elements.forEach((el) => {\r\n        observer.observer.unobserve(el)\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Turns off observers and empty their related targets.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  destroy() {\r\n    this.unobserve()\r\n\r\n    this.observers.forEach((observer) => {\r\n      observer.elements = []\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Resets everything.\r\n   * Turns off observers and resets their targets.\r\n   * Then calls `this.init()` to restart everything with new elements to observe.\r\n   * This will trigger Cartapus events if events are turned on.\r\n   *\r\n   * @public\r\n   * @returns {void}\r\n   */\r\n  reset() {\r\n    this.destroy()\r\n    this.init()\r\n  }\r\n}\r\n"],"names":["Cartapus","Emitter","constructor","options","super","this","intersect","bind","Object","assign","root","rootMargin","threshold","once","events","createMainObserver","init","observers","observer","IntersectionObserver","elements","getElems","createObservers","observe","document","elems","querySelectorAll","el","dataset","cartapusThreshold","parseFloat","found","push","entries","forEach","entry","isIntersecting","target","cartapus","cartapusOnce","unobserve","dispatch","detail","element","visible","intersection","event","CustomEvent","dispatchEvent","emit","destroy","reset"],"mappings":"4BAsBqBA,MAAAA,UAAiBC,EAiBpCC,YAAYC,EAAU,IACpBC,QAGAC,KAAKC,UAAYD,KAAKC,UAAUC,KAAKF,MAWrCA,KAAKF,QAAUK,OAAOC,OARL,CACfC,KAAM,KACNC,WAAY,MACZC,UAAW,EACXC,MAAM,EACNC,QAAQ,GAG6BX,GAGvCE,KAAKU,qBACLV,KAAKW,OASPD,qBACEV,KAAKY,UAAY,CAAC,CAChBC,SAAU,IAAIC,qBAAqBd,KAAKC,UAAWD,KAAKF,SACxDS,UAAWP,KAAKF,QAAQS,UACxBQ,SAAU,KAUdJ,OACEX,KAAKgB,WACLhB,KAAKiB,kBACLjB,KAAKkB,UASPF,WACE,MAAMX,EAA6B,OAAtBL,KAAKF,QAAQO,KAAgBc,SAAWnB,KAAKF,QAAQO,KAElEL,KAAKoB,MAAQf,EAAKgB,iBAAiB,mBAUrCJ,kBACE,IAAK,MAAMK,KAAWF,KAAAA,MAEpB,GAAIE,EAAGC,QAAQC,kBAAmB,CAChC,MAAMjB,EAAYkB,WAAWH,EAAGC,QAAQC,mBACxC,IAAIE,GAAQ,EAGZ,IAAK,MAAMb,KAAYb,KAAKY,UACtBL,IAAcM,EAASN,YACzBmB,GAAQ,EAERb,EAASE,SAASY,KAAKL,IAK3B,IAAKI,EAAO,CACV,MAAMb,EAAW,CACfA,SAAU,IAAIC,qBAAqBd,KAAKC,UAAWE,OAAOC,OAAOJ,KAAKF,QAAS,CAAES,UAAAA,KACjFA,UAAAA,EACAQ,SAAU,CAACO,IAGbtB,KAAKY,UAAUe,KAAKd,SAEZD,KAAAA,UAAU,GAAGG,SAASY,KAAKL,GAe3CrB,UAAU2B,EAASf,GACjBe,EAAQC,QAASC,IAEXA,EAAMC,gBACRD,EAAME,OAAOT,QAAQU,SAAW,UAG5BjC,KAAKF,QAAQU,MAA8C,UAAtCsB,EAAME,OAAOT,QAAQW,cAA0BrB,EAASsB,UAAUL,EAAME,SAC5FF,EAAME,OAAOT,QAAQU,SAAW,SAEnCjC,KAAKF,QAAQW,QAAQT,KAAKoC,SAASN,KAa3CM,SAASN,GAEP,MAAMO,EAAS,CACbC,QAASR,EAAME,OACfO,QAAST,EAAMC,eACfS,aAAcV,GAEVW,EAAQ,IAAIC,YAAY,oBAAqB,CAAEL,OAAAA,IAGrDP,EAAME,OAAOW,cAAcF,GAC3BzC,KAAK4C,KAAK,YAAaP,GAWzBnB,UACElB,KAAKY,UAAUiB,QAAShB,IACtBA,EAASE,SAASc,QAASP,IACzBT,EAASA,SAASK,QAAQI,OAWhCa,YACEnC,KAAKY,UAAUiB,QAAShB,IACtBA,EAASE,SAASc,QAASP,IACzBT,EAASA,SAASsB,UAAUb,OAWlCuB,UACE7C,KAAKmC,YAELnC,KAAKY,UAAUiB,QAAShB,IACtBA,EAASE,SAAW,KAaxB+B,QACE9C,KAAK6C,UACL7C,KAAKW"}