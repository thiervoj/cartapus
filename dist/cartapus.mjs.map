{"version":3,"file":"cartapus.mjs","sources":["../node_modules/tiny-emitter/index.js","../src/cartapus.js"],"sourcesContent":["function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n","/**\n * @file Cartapus core file, dispatches events based on [data-cartapus] elements' visibility in the viewport.\n * @author Jordan Thiervoz <jordanthiervoz@gmail.com>\n */\n\nimport Emitter from 'tiny-emitter'\n\n/**\n * Creates a new Cartapus instance, starting to watch every `[data-cartapus]` elements' visibility right away.\n *\n * Usually you will only need to instanciate Cartapus once for your whole App.\n *\n * @param {Object} [options] — User options.\n * @param {Element} [options.root=document] — The root DOM element into which [data-cartapus] targets will be watched.\n * @param {String} [options.rootMargin=\"0px\"] — A CSS margin property string defining offsets into the `root` element.\n * @param {Number} [options.threshold=0] — A number between 0 and 1 which defines the percentage of height that must be into the viewport for an element to be considered \"visible\".\n * @param {Boolean} [options.once=false] — If \"true\", elements will only toggle to \"visible\" once and never return to their \"hidden\" state.\n *\n * @extends Emitter\n * @class\n */\nexport default class Cartapus extends Emitter {\n  /**\n   * Creates a new Cartapus instance, starting to watch every `[data-cartapus]` elements' visibility right away.\n   *\n   * Usually you will only need to instanciate Cartapus once for your whole App.\n   *\n   * @param {Object} [options] — User options.\n   * @param {Element} [options.root=document] — The root DOM element into which [data-cartapus] targets will be watched.\n   * @param {String} [options.rootMargin=\"0px\"] — A CSS margin property string defining offsets into the `root` element.\n   * @param {Number} [options.threshold=0] — A number between 0 and 1 which defines the percentage of height that must be into the viewport for an element to be considered \"visible\".\n   * @param {Boolean} [options.once=false] — If \"true\", elements will only toggle to \"visible\" once and never return to their \"hidden\" state.\n   *\n   * @extends Emitter\n   * @constructor\n   */\n  constructor(options = {}) {\n    super()\n\n    this.intersect = this.intersect.bind(this)\n    this.mutate = this.mutate.bind(this)\n\n    // Set user options based on default options.\n    const defaults = {\n      root: null,\n      rootMargin: '0px',\n      threshold: 0,\n      once: false\n    }\n\n    this.isObserving = false\n    this.options = Object.assign(defaults, options)\n\n    // Creates the main IntersectionObserver used with the default options.\n    this.observers = [this.createObserver()]\n\n    this.createObservers()\n    this.createMutationObserver()\n    this.observe()\n  }\n\n  /**\n   * For each [data-cartapus] element, check its inner data-cartapus parameters\n   * Create new IntersectionObservers accordingly if parameters differs from the main observer.\n   *\n   * @private\n   * @returns {void}\n   */\n  createObservers() {\n    const root = this.options.root ? this.options.root : document\n    const elems = root.querySelectorAll('[data-cartapus]')\n\n    for (const el of elems) {\n      this.storeNewElement(el)\n    }\n  }\n\n  /**\n   * Gets the observer configuration object for the given element.\n   *\n   * @param {Element} el A DOM element.\n   *\n   * @returns {(undefined|Object)} The found observer object, `undefined` if not found.\n   */\n  findObserverForElement(el) {\n    if (!el) return\n\n    const threshold = el.dataset.cartapusThreshold ? parseFloat(el.dataset.cartapusThreshold) : this.options.threshold\n    const rootMargin = el.dataset.cartapusRootMargin ? el.dataset.cartapusRootMargin : this.options.rootMargin\n\n    // If an observer already exists with the same threshold & the same rootMargin, add element to this observer.\n    const found = this.observers.find((observer) => observer.threshold === threshold && observer.rootMargin === rootMargin)\n\n    return found\n  }\n\n  /**\n   * Stores a new DOM element to be watched. Creating a new `IntersectionObserver` if needed.\n   *\n   * @param {Element} el A DOM element.\n   *\n   * @returns {Boolean} True if a new element is being watched, else false.\n   */\n  storeNewElement(el) {\n    if (!el || !el.hasAttribute || !el.hasAttribute('data-cartapus')) return false\n\n    // If element has a custom cartapus attribute.\n    if (el.dataset.cartapusThreshold || el.dataset.cartapusRootMargin) {\n      const observer = this.findObserverForElement(el)\n\n      if (observer) {\n        observer.elements.push(el)\n\n        el._cartapus = observer\n      } else {\n        const threshold = el.dataset.cartapusThreshold ? parseFloat(el.dataset.cartapusThreshold) : this.options.threshold\n        const rootMargin = el.dataset.cartapusRootMargin ? el.dataset.cartapusRootMargin : this.options.rootMargin\n\n        // If no observer has the same threshold & rootMargin, create a new one with the new options.\n        this.observers.push(this.createObserver({\n          element: el,\n          options: {\n            threshold,\n            rootMargin\n          }\n        }))\n      }\n    } else {\n      this.observers[0].elements.push(el)\n\n      el._cartapus = this.observers[0]\n    }\n\n    return true\n  }\n\n  /**\n   * Creates a new `IntersectionObserver` with the given options. Optionally watching a given element.\n   *\n   * @param {(undefined|Object)} param An object containing parameters.\n   * @param {(undefined|Object)} param.options An object containing the `IntersectionObserver` parameters.\n   * @param {(undefined|Element)} param.element A DOM Element to start observing with the newly created observer.\n   *\n   * @returns {Object} An object with the related observer values.\n   */\n  createObserver({ options, element } = {}) {\n    const opt = Object.assign(this.options, options)\n    const observer = {\n      observer: new IntersectionObserver(this.intersect, opt),\n      threshold: opt.threshold,\n      rootMargin: opt.rootMargin,\n      elements: element ? [element] : [],\n      once: element && element.hasAttribute('data-cartapus-once') && element.getAttribute('data-cartapus-once') !== 'false' ? true : opt.once\n    }\n\n    if (element) element._cartapus = observer\n\n    return observer\n  }\n\n  /**\n   * Creates the MutationObserver.\n   *\n   * @private\n   * @returns {void}\n   */\n  createMutationObserver() {\n    this.mutationObserver = new MutationObserver(this.mutate)\n\n    this.mutationObserver.observe(this.options.root ? this.options.root : document.body, {\n      childList: true,\n      subtree: true\n    })\n  }\n\n  /**\n   * Callback function triggered by the observers.\n   * Sets the data-cartapus attribute accordingly to the visibility of the elements.\n   * Triggers the custom events.\n   *\n   * @param {array.<IntersectionObserverEntry>} entries — An array of entries that intersected with the root.\n   * @param {IntersectionObserver} observer — The observer that triggered the event.\n   *\n   * @private\n   * @returns {void}\n   */\n  intersect(entries, observer) {\n    for (const entry of entries) {\n      // Set data-cartapus attribute value either to \"visible\" or \"hidden\".\n      if (entry.isIntersecting) {\n        entry.target.setAttribute('data-cartapus', 'visible')\n\n        const once = entry.target.getAttribute('data-cartapus-once')\n\n        if (once === 'false') continue\n\n        // Stop observing this element if \"once\" options it true.\n        if (entry.target._cartapus.once || once !== null) observer.unobserve(entry.target)\n      } else entry.target.setAttribute('data-cartapus', 'hidden')\n\n      this.dispatch(entry)\n    }\n  }\n\n  /**\n   * Triggers the CustomEvent `cartapusintersect` on the entry's target.\n   * Also triggers an `intersect` event on the class instance.\n   *\n   * @param {IntersectionObserverEntry} entry — The entry that intersected.\n   *\n   * @private\n   * @returns {void}\n   */\n  dispatch(entry) {\n    // Create event with details.\n    const detail = {\n      element: entry.target,\n      visible: entry.isIntersecting,\n      intersection: entry\n    }\n    const event = new CustomEvent('cartapusintersect', { detail })\n\n    // Dispatch element and instance events.\n    entry.target.dispatchEvent(event)\n    this.emit('intersect', detail)\n  }\n\n  /**\n   * This method is called on every mutation of the DOM.\n   *\n   * @param {Array<MutationRecord>} records A array of MutationRecords.\n   *\n   * @private\n   * @returns {void}\n   */\n  mutate(records) {\n    for (const record of records) {\n      if (record.type === 'childList') {\n        for (const addedNode of record.addedNodes) {\n          const success = this.storeNewElement(addedNode)\n\n          if (success) addedNode._cartapus.observer.observe(addedNode)\n\n          if (addedNode._cartapus) {\n            const inners = addedNode.querySelectorAll('[data-cartapus]')\n\n            for (const el of inners) {\n              const success = this.storeNewElement(el)\n\n              if (success && el._cartapus) el._cartapus.observer.observe(el)\n            }\n          }\n        }\n\n        for (const removedNode of record.removedNodes) {\n          if (removedNode._cartapus) {\n            const index = removedNode._cartapus.elements.indexOf(removedNode)\n\n            removedNode._cartapus.elements.splice(index, 1)\n            removedNode._cartapus.observer.unobserve(removedNode)\n          }\n\n          if (removedNode._cartapus) {\n            const inners = removedNode.querySelectorAll('[data-cartapus]')\n\n            for (const el of inners) {\n              if (el._cartapus) {\n                const index = el._cartapus.elements.indexOf(el)\n\n                el._cartapus.elements.splice(index, 1)\n                el._cartapus.observer.unobserve(el)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Turns on all the observers to watch all of their related targets.\n   *\n   * This will trigger Cartapus events.\n   *\n   * @public\n   * @returns {void}\n   */\n  observe() {\n    if (this.isObserving) return\n\n    this.isObserving = true\n\n    for (const observer of this.observers) {\n      for (const el of observer.elements) {\n        observer.observer.observe(el)\n      }\n    }\n  }\n\n  /**\n   * Turns off all the observers to stop watching all of their related targets.\n   *\n   * @public\n   * @returns {void}\n   */\n  unobserve() {\n    if (!this.isObserving) return\n\n    this.isObserving = false\n\n    for (const observer of this.observers) {\n      for (const el of observer.elements) {\n        observer.observer.unobserve(el)\n      }\n    }\n  }\n\n  /**\n   * Triggers the cartapus events for the given targets. If no targets are given, all the elements will trigger their events.\n   *\n   * @param {(undefined|Array<Element>|Element)} targets - An element or an array of elements.\n   *\n   * @public\n   * @returns {void}\n   */\n  triggerEvent(targets) {\n    if (targets) {\n      const els = Array.isArray(targets) ? targets : [targets]\n\n      for (const el of els) {\n        if (el._cartapus) {\n          el._cartapus.observer.unobserve(el)\n          el._cartapus.observer.observe(el)\n        }\n      }\n\n      return\n    }\n\n    for (const observer of this.observers) {\n      for (const el of observer.elements) {\n        observer.observer.unobserve(el)\n        observer.observer.observe(el)\n      }\n    }\n  }\n\n  /**\n   * Start watching a given Element. Use in case the `data-cartapus` attribute has been added after the Element has been appended to the DOM.\n   *\n   * @param {Element} el A DOM element to start observing.\n   *\n   * @returns {Boolean} Whether the Element is now being observed or not.\n   */\n  add(el) {\n    const success = this.storeNewElement(el)\n\n    if (success) el._cartapus.observer.observe(el)\n\n    return success\n  }\n\n  /**\n   * Turns off observers and empty their related targets.\n   *\n   * @public\n   * @returns {void}\n   */\n  destroy() {\n    this.unobserve()\n    this.mutationObserver.disconnect()\n\n    for (const observer of this.observers) {\n      for (const el of observer.elements) {\n        delete el._cartapus\n      }\n\n      observer.observer.disconnect()\n      observer.elements = []\n    }\n  }\n}\n"],"names":["E","prototype","on","name","callback","ctx","e","this","push","fn","once","self","listener","off","apply","arguments","_","emit","data","slice","call","evtArr","i","len","length","evts","liveEvents","tinyEmitter","Cartapus","_Emitter","options","_this","intersect","bind","_assertThisInitialized","mutate","isObserving","Object","assign","root","rootMargin","threshold","observers","createObserver","createObservers","createMutationObserver","observe","Emitter","_step","elems","document","querySelectorAll","_iterator","done","storeNewElement","value","findObserverForElement","el","dataset","cartapusThreshold","parseFloat","cartapusRootMargin","find","observer","_proto","hasAttribute","elements","_cartapus","element","_temp","_ref","opt","IntersectionObserver","getAttribute","mutationObserver","MutationObserver","body","childList","subtree","entries","_step2","_iterator2","entry","isIntersecting","target","setAttribute","unobserve","dispatch","detail","visible","intersection","CustomEvent","dispatchEvent","event","records","_step3","_iterator3","record","type","addedNodes","addedNode","_step4","_step6","inners","_iterator6","_step5","removedNodes","_iterator5","removedNode","index","indexOf","splice","_step7","_iterator7","_createForOfIteratorHelperLoose","_el","_step8","_iterator8","_step9","_iterator9","_step10","_iterator10","triggerEvent","targets","els","Array","isArray","_step12","_step13","_iterator13","_step14","_iterator14","add","success","destroy","disconnect","_step15","_iterator15","_step16"],"mappings":"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"}